<!DOCTYPE html>
<html lang="ch">
	<head>
		<meta charset="utf-8">
		<title>JQuery—Test1day</title>、
		<script src="https://code.jquery.com/jquery-1.12.4.js"
		integrity="sha256-Qw82+bXyGq6MydymqBxNPYTaUXXq7c8v3CwiYwLLNXU="
		crossorigin="anonymous"></script>

		<script type="text/javascript">
			/*
			window.onload=function(){
				//1、通过原生js的入口函数可以拿到DOM元素
				var img=document.getElementsByTagName("img")[0];
				console.log(img);
				//2.通过原生的JS入口函数可以拿到DOM元素的宽高
				var width=window.getComputedStyle(img).width;
				console.log("onload",width);
			}
			*/
			/*
			*原生JS和JQuery入口函数的加载模式不同
			* 原生JS会等DOM元素加载完毕，并且图片也加载完毕才会执行
			* JQuery会等到DOM元素加载完毕，但不会等到图片也加载完毕就会执行
			* */
			/*
			$(document).ready(function(){
				//通过JQuery的入口函数可以拿到DOM元素
				var $img=$("img")[0];
				console.log($img);
				//2.通过JQuery的入口函数不可以拿到DOM元素的宽高
				var $width=$img.width();
				console.log("ready",$width);
			});*/
			/*
			原生的JS如果编写了多个入口函数，后面编写的会覆盖前面编写的
			*/
			/* window.onload=function(ev){
				alert("hello INj1");
				
			}
			window.onload=function(ev){
				alert("hello INj2");
			} */
			/* $(document).ready(function(){
				alert("hello INj1");
			});
			$(document).ready(function(){
				alert("hello INj2");
			}); */
			////////////////////////////////试验一下提交第一次
			////////////////////////////////测试一下提交第二次
			/* 总结可以在hbuilderX里面先提交,再在gitbase里面上传 */
			
			
			
			////////////////////////////// 8.11晚上   Jquery入口函数的四种编写方式 
		/* 	//第一种写法
			$(document).ready(function(){
				alert("hello Inj");
			});
			//2.第二种写法
			JQuery(document).ready(function(){
				alert("hello inj");
			}); 
			//第三种写法(推荐)
			$(function(){
				alert("hello Inj");
			});
			//第四种写法
			JQuery(function(){
				alert("hello inj");
			}); */
			//////////////////////////////////////////////////////jquery的冲突问题
			/* var nj=jQuery.noConflict();
			$(function(){
				alert("hello lnj");
			}); */
			//1、假如后引入一个文件,里面定义了$符号,这个时候jquery退一步海阔天空,释放$的使用权,在其他jquery代码前面加JQuery.noConflict();释放后就不能用$要换成JQuery
		    //2.为了解决代码又臭又长自定义一个访问符号var nj=jQuery.noConflict();
			
			
			/////////////////////////////////////////////////jQuery的核心函数
			//$();就代表调用jquery的核心函数
			
			
			//1.接受一个函数(入口函数)
              /*  $(function(){
					 alert("hello lnj")}); 
					//2.接收一个字符串
					  //2.1接受一个字符串选择器,用于查找元素，原理是返回一个jquery对象,对象中保存了找到的dom元素
					    var $box1=$(".box1");
					    var $box2=$("#box2");
						console.log($box1);
						console.log($box2); 
						
					  //2.2接收一个字符串代码片段,创建这个代码片段的对应元素，原理是返回一个jquery对象,对象中保存了创建的DOM元素
					  var $p=$("<p>我是段落</p>");
					  console.log($p);
					  $box1.append($p); 
					//3.接受一个DOM元素,原理是会被包装成一个jquery对象返回给我们
					var span=document.getElementsByTagName("span")[0];
					console.log(span);
				    var $span=$(span);
					console.log($span); 
				});
			 */
			///////////////////////////////////8.12晚上        jqurey对象
			/*
				*1.什么是jquery对象
				* jquery对象是一个伪数组
				* 2.什么是伪数组
				* 有0到length-1的属性，并且有length属性
				*/
			/* $(function(){
			    var $div=$("div");
				console.log($div);
				var arr=[1,3,5];
				console.log(arr); 
				});*/ 
			///////////////////////////////////8.13静态方法和实例方法	
				/* //1.定义一个类
				function AClass(){
					
				};
				//2.给这个类添加一个静态方法
				//直接添加给类的就是一个静态方法
               AClass.staticMethod=function  () {
                alert("staticmethod");	
               }
			   //静态方法通过类名来调用
			  AClass.staticMethod();
			  //3.给这个类添加一个实例方法
			  AClass.prototype.instanceMethod=function(){
				  alert("instanncemethod");
			  }
			  //实例方法通过类的实例调用
			  //创建一个实例(创建一个实例)
			  var a=new AClass();
			  //通过实例调用实例方法
			  a.instanceMethod(); */
		  ////////////////////////////////////////////静态方法each方法
    /* var arr=[1,3,5,7,9];
	var obj={0:1,1:3,2:5,3:7,4:9,length:5}; */
	/*
	*第一个参数：遍历到的元素
	* 第二个参数：当前遍历到的索引
	* 注意点：
	* 原生的foreach只能遍历数组，不能遍历伪数组
	* 
	*/
	/* arr.forEach(function(value,index){
		console.log(index,value);
	}) */
	//obj.forEach(function(value,index){
	//	console.log(index,value);//JQuery.html:155 Uncaught TypeError: obj.forEach is not a function
	//});
	
	//1.利用jQuery的each静态方法遍历数组
	/* 
	*第一个参数：当前遍历到的索引
	* 第二个参数：遍历到的元素
	* 注意点：jquery的each方法是可以遍历伪数组的
	 */
	/* $.each(arr,function(index,value){
		console.log(index,value);
	});
	$.each(obj,function(index,value){
		console.log(index,value);
	}); */ 
	///////////////////////////////8.16静态方法map方法
	/* var arr=[1,3,5,7,9];
	var obj={0:1,1:3,2:5,3:7,4:9,length:5}; */
	//1.利用原生的js的map方法遍历
	/*
	第一个参数：当前遍历到的元素
	第二个参数：当前遍历到的索引
	第三个参数：当前被遍历的数组
	注意点：
	和原生的foreach一样，不能遍历的伪数组
	*/
	/* arr.map(function(value,index,array){
		 console.log(index,value,array);
	 });
	 obj.map(function(value,index,array){
	 		 console.log(index,value,array);
	 }); */
	 /* 
	 第一个参数：要遍历的数组
	 第二个参数：每遍历一个元素之后执行的回调函数
	 回调函数的参数：
	 第一个参数：遍历到的元素
	 第二个人参数：遍历到的索引
	 注意点：
	 和jQuery中的each静态方法一样，map静态方法也可以遍历伪数组
	 */
	/* $.map(arr,function(value,index){
		 console.log(index,value);
	 });
	var res= $.map(obj,function(value,index){
	 		 console.log(index,value);
			 return value+index;
	 });
	var res2= $.each(obj,function(index,value){
	 	console.log(index,value);
		return value+index;
	 }); */
	 /* 
	 jquery中的each静态方法和map静态方法的区别
	 each静态方法默认的返回值就是，遍历谁返回谁
	 map静态方法默认的返回值是一个空数组
	 
	 each 静态方法不支持不支持在回调函数中对遍历的数组进行处理
	 map静态方法可以在回调函数中通过return对遍历到数组进行处理然后生成一个新的数组返回
	 */
	 /* console.log(res);
	 console.log(res2); */
/////////////////////////////////////////////////////////////jquery中的其他静态方法
     /* 
	 $.trim();
	 作用：去除字符串两端的空格
	 参数：需要去除空格的字符串
	 返回值：去除空格之后的字符串
	 */
	 /* var str="    lnj    ";
	 var res =$.trim(str);
	 console.log("————"+str+"————");
     console.log("————"+res+"————"); */
	  var arr=[1,3,5,7,9];//真数组
	 var arrlike={0:1,1:3,2:5,3:7,4:9,length:5};//伪数组
	 var obj={"name":"lnj",age:"33"};//对象
	 var fn=function(){};//函数
	 var w=window;//window对象
	 /* 
	 $.isWindow();
	 作用：判断传入的对象时候是window对象
	 返回值：ture/false
	 */
	 /* var res =$.isWindow(w);
		console.log(res); */
			 /* 
		$.isArray();
		作用：判断传入的对象时候是否是真数组
		返回值：ture/false
		*/
	/* 	var res=$.isArray(arr);
		console.log(res); */
		
	    /*
		 $.isFunction();
		作用：判断传入的对象时候是否是函数
		返回值：ture/false
		
		注意点：
           jQuery框架本质上是一个立命函数；
		   （function（window，undefined）{
		   }）（window）；
		*/
	/* 	var res=$.isFunction(jQuery);
			console.log(res); */
			
			///////////////////////////////////jquery-holdReady方法
	     /* 
		 		 $.holdReady(true);
				 作用：暂停ready执行
		 */
		 $.holdReady(true);
		 $(document).ready(function(){
			 alert("ready");
		 });
		 /////////////////////////////////8.19通过webstorm简化操作
           
		/////////////////////////////////8.20
		</script>
	</head>
	<body>
		<div class="box1"></div>
		<div id="box2"></div>
		<span>我是一个span</span>
		<div>div1</div>
		<div>div2</div>
		<div>div3</div>
		<button type="button">恢复ready事件</button>
		<script type="text/javascript">
			var btn=document.getElementsByTagName("button")[0];
			btn.onclick=function(){
						 $.holdReady(false);
			}
		</script>
		<img src="https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo_top_86d58ae1.png" alt=""/>
	</body>
</html>
